#Область ПрограммныйИнтерфейс

#Область ИсходящаяОчередь

// Процедура - Выполнить обмен СШП
//
// Параметры:
//  Источник - Справочник.Объект, Документ.Объект - объект-источник события.
//  Отказ - Булево - Признак отказа от дальнейшей обработки.
//
Процедура ВыполнитьОбменСШП(Источник, Отказ) Экспорт
	
	Если Не Отказ Тогда
		
		ссИсточник = Источник.Ссылка;	//ссылка на объект-источник события, который нужно разместить в исходящую очередь СШП.
		
		ЗарегистрироватьСобытие(ссИсточник);
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура - Обработать исходящую очередь
//	Процедура вызывается из рег.задания с целью сформировать тело сообщения:
//		- получает структура класса
//		- заполняет структуру данными примитивного типа
//		- сохраняет структуру данных в формате JSON и размещает в Тело записи собщения
//	При успешном выполнении запись сообщения изменит статус с Новое на Обработано.
//
Процедура ОбработатьИсходящуюОчередь() Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 50
	|	сшпОчередьИсходящихСообщений.Идентификатор
	|ИЗ
	|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
	|ГДЕ
	|	сшпОчередьИсходящихСообщений.СтатусСообщения = Значение(Перечисление.сшпСтатусыСообщений.Новое)
	|	И сшпОчередьИсходящихСообщений.КоличествоПопыток < &КоличествоПопыток
	|	И сшпОчередьИсходящихСообщений.ВРаботе = ЛОЖЬ
	|";
	
	Запрос.УстановитьПараметр("КоличествоПопыток", сшпОбщегоНазначения.ПолучитьКоличествоПопытокПередачиОбъекта());
	
	ГСЧ = Новый ГенераторСлучайныхЧисел();
	
	перСтатусОбработано = Перечисления.сшпСтатусыСообщений.Обработано;
	
	Пока Истина Цикл
		
		//В каждой итерации цикла из очереди (РС) формируется выборка объектов количеством не более 50 штук.
		//В выборку попадают объекты, которые:
		//	- не обрабатываются другим экз.рег.задания
		//	- количество попыток мигрировать их в СШП не более раз* (контролируется константой)
		//
		//Из сформированной выборки объектов случайным образом выбираем один объект
		//и предпринимаем попытку его миграции в СШП.
		//
		//Цикл бесконечный и прерывается только в случае отсутствие объектов в очереди
		//удовлетворяющих условиям попадания в выборку.
		
		тзВыборкаОбъектов = Запрос.Выполнить().Выгрузить();	//формируем выборку объектов.
		чРазмерВыборки = тзВыборкаОбъектов.Количество();
		Если чРазмерВыборки = 0 Тогда
			
			//Нет объектов для миграции в СШП.
			
			Прервать;
			
		КонецЕсли;
		
		НомерСС = ГСЧ.СлучайноеЧисло(0, чРазмерВыборки - 1);
		
		ИдентификаторСообщения = тзВыборкаОбъектов[НомерСС].Идентификатор;	//выбираем из выборки объектов случайным образом объект для миграции его в СШП.
		
		НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);
		
		Блокировка  		= Новый БлокировкаДанных;
		ЭлементБлокировки   = Блокировка.Добавить("РегистрСведений.сшпОчередьИсходящихСообщений");
		ЭлементБлокировки.УстановитьЗначение("Идентификатор", ИдентификаторСообщения);
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
		
		Попытка
			
			Блокировка.Заблокировать();
			
		Исключение
			
			ЗафиксироватьТранзакцию();	//например, объект блокирован другим экз.рег.задания.
			
			Продолжить;
			
		КонецПопытки;
		
		МЗ = РегистрыСведений.сшпОчередьИсходящихСообщений.СоздатьМенеджерЗаписи();
		МЗ.Идентификатор = ИдентификаторСообщения;
		МЗ.Прочитать();
		
		Если Не МЗ.Выбран() Тогда
			
			ЗафиксироватьТранзакцию();	//объект уже обработан другим экз.рег.задания.
			
			Продолжить;
			
		ИначеЕсли МЗ.ВРаботе Тогда
			
			ЗафиксироватьТранзакцию();	//объект в работе у другого экз.рег.задания.
			
			Продолжить;
			
		Иначе
			
			//Ставим метку для других экз.рег.заданий, что объект взят в работу.
			
			МЗ.ВРаботе = Истина;
			МЗ.ДатаОбработки = ТекущаяДатаСеанса();
			МЗ.Записать(Истина);
			
			ЗафиксироватьТранзакцию();
			
		КонецЕсли;
		
		/////
		//04.11.18
		//ВАЖНО: Если далее произойдет завершение процесса 1С, то в очереди (РС) останется объект,
		//который помечен "В работе" и в итоге:
		//	- нет процесса экз.рег.задания, которое обрабатывало объект
		//	- объект в виду статуса не будет попадать в выборки других экз.рег.заданий
		//То есть объект не будет мигрировать в СШП ("завис" в миграции).
		//
		//Проведем наблюдения на образование подобных "висяков", если будет иметь место,
		//то добавим параметр в очередь (например, ID процесса или время размещения в очереди)
		//по анализу которого будем признак "В работе" снимать.
		
		Попытка
			
			стДанные = сшпРаботаСКлассамиСервер.ПолучитьСтруктуруОбъектаКласса(МЗ.Класс);
			Если стДанные = Неопределено Тогда
				
				//Структура класса интеграции не определена.
				
				стрИмяСобытия	  = сшпОбщегоНазначенияПовтИсп.ИмяСобытияЖурналаРегистрации();
				УровеньСобытия	  = УровеньЖурналаРегистрации.Ошибка;
				стрОписаниеОшибки = НСтр("ru = 'В классе интеграции: """ + МЗ.Класс + """ не определена структура.'", сшпОбщегоНазначенияПовтИсп.КодОсновногоЯзыка());
				
				ЗаписьЖурналаРегистрации(стрИмяСобытия, УровеньСобытия, МЗ.Класс.Метаданные(), МЗ.Класс, стрОписаниеОшибки);
				
				МЗ.КоличествоПопыток = МЗ.КоличествоПопыток + 1;
				МЗ.ПоследняяОшибка	 = "В классе интеграции не определена его структура.";
				МЗ.ВРаботе			 = Ложь;
				МЗ.ДатаОбработки	 = Дата(1, 1, 1);
				МЗ.Записать(Истина);
				
				Продолжить;
				
			КонецЕсли;
			
			/////
			//Структура данных для формирования тела сообщения получена.
			
			Попытка
				
				///////////////////////////////////////////////////////////////////////
				//Выполняем обработчик класса интеграции ---> получаем тело сообщения//
				///////////////////////////////////////////////////////////////////////
				стПараметрыВызова = Новый Структура;
				стПараметрыВызова.Вставить("ПроцедураОбработки", МЗ.Класс.ПроцедураОбработки);
				
				стрПараметрыВызова = МЗ.ВходящиеПараметры;
				Если Не ПустаяСтрока(стрПараметрыВызова) Тогда
					
					стПараметрыВызова.Вставить("Параметры", сшпФункцииРаботыJSON.ЧтениеПрикладныхОбъектовJSON(стрПараметрыВызова));
					
				КонецЕсли;
				
				фстПараметрыВызова = Новый ФиксированнаяСтруктура(стПараметрыВызова);
				
				ВыполнитьОбработчикКласса(МЗ.Объект, стДанные, фстПараметрыВызова);
				
				///////////////////////////////////////////////////////////////////////
				//Добавдение версии объекта, при которой было сформировано сообщение.//
				///////////////////////////////////////////////////////////////////////
				Если МЗ.Класс.ПередаватьВерсиюОбъекта Тогда
					
					Если МЗ.Объект <> Неопределено Тогда	//если в классе указано передавать версию объекта, а он не указан, то версию не передаем
						
						Если Не МЗ.Объект.Пустая() Тогда	//если объект не выбран, версию не передаем
							
							ДобавитьВерсиюОбъекта(МЗ.Объект, стДанные);
							
						КонецЕсли;
						
					КонецЕсли;
					
				КонецЕсли;
				
				стрТелоСобщения = сшпФункцииРаботыJSON.ПростаяЗаписьJSON(стДанные);
				
			Исключение
				
				Инфо			  = ОписаниеОшибки();
				стрИмяСобытия  	  = сшпОбщегоНазначенияПовтИсп.ИмяСобытияЖурналаРегистрации();
				УровеньСобытия 	  = УровеньЖурналаРегистрации.Ошибка;
				стрОписаниеОшибки = НСтр("ru = 'При выполнении обработчика класса интеграции: """ + МЗ.Класс + """  возникла ошибка:
				|" + Инфо + "'", сшпОбщегоНазначенияПовтИсп.КодОсновногоЯзыка());
				
				ЗаписьЖурналаРегистрации(стрИмяСобытия, УровеньСобытия, МЗ.Класс.Метаданные(), МЗ.Класс, стрОписаниеОшибки);
				
				//Фиксируем не успешную попытку выполнения обработчика класса интеграции для объекта.
				МЗ.КоличествоПопыток = МЗ.КоличествоПопыток + 1;
				МЗ.ПоследняяОшибка 	 = Инфо;
				МЗ.ВРаботе			 = Ложь;
				МЗ.ДатаОбработки	 = Дата(1, 1, 1);
				МЗ.Записать(Истина);
				
				Продолжить;
				
			КонецПопытки;
			
			//Обработка выполнена успешно, обновляем запись в очереди.
			МЗ.Тело				 = стрТелоСобщения;
			МЗ.СтатусСообщения	 = перСтатусОбработано;
			МЗ.КоличествоПопыток = 0;
			МЗ.ПоследняяОшибка	 = "";
			МЗ.ВРаботе			 = Ложь;
			МЗ.Записать(Истина);
			
		Исключение
			
			//Общее исключение при миграции объекта в СШП (используется при общем разборе ошибок).
			//Например, при получении определения структуры класса интеграции.
			МЗ.КоличествоПопыток = МЗ.КоличествоПопыток + 1;
			МЗ.ПоследняяОшибка	 = ОписаниеОшибки();
			МЗ.ВРаботе			 = Ложь;
			МЗ.ДатаОбработки	 = Дата(1, 1, 1);
			МЗ.Записать(Истина);
			
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура - Обработать отправку сообщений
//	Процедура вызывается из рег.задания с целью сформировать сообщение сервиса интеграции и разместить его в системную очередь.
//		- определяем параметры сообщения: отправитель, получатель и т.п.
//		- формируем сообщение объекта сервиса интеграции
//		- размещаем сообщение в системной очереди сообщений
//	При успешном выполнении запись сообщения изменит статус с Обработано на ОжиданиеОтправки.
//
Процедура ОбработатьОтправкуСообщений() Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 50
	|	сшпОчередьИсходящихСообщений.Идентификатор
	|ИЗ
	|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
	|ГДЕ
	|	сшпОчередьИсходящихСообщений.СтатусСообщения = Значение(Перечисление.сшпСтатусыСообщений.Обработано)	//готовы к размещению в системную очередь 1С Предприятие
	|	И сшпОчередьИсходящихСообщений.КоличествоПопыток < &КоличествоПопыток
	|	И сшпОчередьИсходящихСообщений.ВРаботе = ЛОЖЬ
	|";
	
	Запрос.УстановитьПараметр("КоличествоПопыток", сшпОбщегоНазначения.ПолучитьКоличествоПопытокПередачиОбъекта());
	
	ГСЧ = Новый ГенераторСлучайныхЧисел();
	
	перСтатусОжиданиеОтправки = Перечисления.сшпСтатусыСообщений.ОжиданиеОтправки;
	
	Пока Истина Цикл
		
		//В каждой итерации цикла из очереди (РС) формируется выборка объектов количеством не более 50 штук.
		//В выборку попадают объекты, которые:
		//	- не обрабатываются другим экз.рег.задания
		//	- количество попыток мигрировать их в СШП не более раз* (контролируется константой)
		//
		//Из сформированной выборки объектов случайным образом выбираем один объект
		//и предпринимаем попытку его миграции в СШП.
		//
		//Цикл бесконечный и прерывается только в случае отсутствие объектов в очереди
		//удовлетворяющих условиям попадания в выборку.
		
		тзВыборкаОбъектов = Запрос.Выполнить().Выгрузить();	//формируем выборку объектов.
		чРазмерВыборки = тзВыборкаОбъектов.Количество();
		Если чРазмерВыборки = 0 Тогда
			
			//Нет объектов для миграции в СШП.
			
			Прервать;
			
		КонецЕсли;
		
		НомерСС = ГСЧ.СлучайноеЧисло(0, чРазмерВыборки - 1);
		
		ИдентификаторСообщения = тзВыборкаОбъектов[НомерСС].Идентификатор;	//выбираем из выборки объектов случайным образом объект для миграции его в СШП.
		
		НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);
		
		Блокировка  		= Новый БлокировкаДанных;
		ЭлементБлокировки   = Блокировка.Добавить("РегистрСведений.сшпОчередьИсходящихСообщений");
		ЭлементБлокировки.УстановитьЗначение("Идентификатор", ИдентификаторСообщения);
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
		
		Попытка
			
			Блокировка.Заблокировать();
			
		Исключение
			
			ЗафиксироватьТранзакцию();	//например, объект блокирован другим экз.рег.задания.
			
			Продолжить;
			
		КонецПопытки;
		
		МЗ = РегистрыСведений.сшпОчередьИсходящихСообщений.СоздатьМенеджерЗаписи();
		МЗ.Идентификатор = ИдентификаторСообщения;
		МЗ.Прочитать();
		
		Если Не МЗ.Выбран() Тогда
			
			ЗафиксироватьТранзакцию();	//объект уже обработан другим экз.рег.задания.
			
			Продолжить;
			
		ИначеЕсли МЗ.ВРаботе Тогда
			
			ЗафиксироватьТранзакцию();	//объект в работе у другого экз.рег.задания.
			
			Продолжить;
			
		Иначе
			
			//Ставим метку для других экз.рег.заданий, что объект взят в работу.
			
			МЗ.ВРаботе = Истина;
			МЗ.ДатаОтправки = ТекущаяДатаСеанса();
			МЗ.Записать(Истина);
			
			ЗафиксироватьТранзакцию();
			
		КонецЕсли;
		
		/////
		//04.11.18
		//ВАЖНО: Если далее произойдет завершение процесса 1С, то в очереди (РС) останется объект,
		//который помечен "В работе" и в итоге:
		//	- нет процесса экз.рег.задания, которое обрабатывало объект
		//	- объект в виду статуса не будет попадать в выборки других экз.рег.заданий
		//То есть объект не будет мигрировать в СШП ("завис" в миграции).
		//
		//Проведем наблюдения на образование подобных "висяков", если будет иметь место,
		//то добавим параметр в очередь (например, ID процесса или время размещения в очереди)
		//по анализу которого будем признак "В работе" снимать.
		
		фстДанные = сшпРаботаСКлассамиСервер.ПолучитьСтруктуруДанныхДляФормированияСообщенияВСШП(МЗ.Класс);
		
		/////
		//Структура данных для формирования сообщения получена.
		
		Попытка
			
			///////////////////////////////////////////////////////////
			//Формируем сообщение и размещаем его в системной очереди//
			///////////////////////////////////////////////////////////
			
			ссСервисИнтеграции = СервисыИнтеграции[фстДанные.ИмяСервисаИнтеграции];
			
			//Можно добавить проверку на активность сервиса. Пока оставили в общей попытке
			
			ссиСообщение = ссСервисИнтеграции.СоздатьСообщение();	//например, СервисыИнтеграции.sample02.СоздатьСообщение();
			ссиСообщение.КодОтправителя = фстДанные.КодОтправителя;	//например, "office";
			ссиСообщение.КодПолучателя = фстДанные.КодПолучателя;	//например, "shop-1";
			ссиСообщение.Параметры.Вставить("ТипЗапроса", фстДанные.ТипЗапроса);	//например, "ИзменениеДанных"
			ссиСообщение.Параметры.Вставить("Класс", МЗ.Класс.Наименование);
			ссиСообщение.Параметры.Вставить("ДатаСоздания", МЗ.ДатаСоздания);
			
			ИмяВременногоФайла = ПолучитьИмяВременногоФайла("JSON");
			
			Текст = Новый ТекстовыйДокумент;
			Текст.УстановитьТекст(МЗ.Тело);
			Текст.Записать(ИмяВременногоФайла);
			
			Поток = ФайловыеПотоки.Открыть(ИмяВременногоФайла, РежимОткрытияФайла.Открыть, ДоступКФайлу.Чтение);
			
			ФайлВложение = Новый Файл(ИмяВременногоФайла);
			РазмерФайла = ФайлВложение.Размер();
			ссиСообщение.Параметры["РазмерСообщения"] = РазмерФайла;
			
			Тело = ссиСообщение.ПолучитьТелоКакПоток();
			Поток.КопироватьВ(Тело);
			Тело.СброситьБуферы();
			Тело.Закрыть();
			Поток.Закрыть();
			
			ссСервисИнтеграции[фстДанные.ИмяКанала].ОтправитьСообщение(ссиСообщение);
			
		Исключение
			
			ФайлСТеломСообщения = Новый Файл(ИмяВременногоФайла);
			Если ФайлСТеломСообщения.Существует() Тогда
				
				УдалитьФайлы(ИмяВременногоФайла);
				
			КонецЕсли;
			
			Инфо			  = ОписаниеОшибки();
			стрИмяСобытия  	  = сшпОбщегоНазначенияПовтИсп.ИмяСобытияЖурналаРегистрации();
			УровеньСобытия 	  = УровеньЖурналаРегистрации.Ошибка;
			стрОписаниеОшибки = НСтр("ru = 'При создании сообщения и размещения его в системной очереди 1С:Предприятия для сообщения с идентификатором: """ + МЗ.Идентификатор + """  возникла ошибка:
			|" + Инфо + "'", сшпОбщегоНазначенияПовтИсп.КодОсновногоЯзыка());
			
			ЗаписьЖурналаРегистрации(стрИмяСобытия, УровеньСобытия,, МЗ.Идентификатор, стрОписаниеОшибки);
			
			//Фиксируем не успешную попытку формирования сообщения и его размещения в системной очереди 1С:Предприятия.
			МЗ.КоличествоПопыток = МЗ.КоличествоПопыток + 1;
			МЗ.ПоследняяОшибка 	 = Инфо;
			МЗ.ВРаботе			 = Ложь;
			МЗ.ДатаОтправки		 = Дата(1, 1, 1);
			МЗ.Записать(Истина);
			
			Продолжить;
			
		КонецПопытки;
		
		//Обработка выполнена успешно, удаляем временный файл и обновляем запись в очереди.
		УдалитьФайлы(ИмяВременногоФайла);
		
		МЗ.СтатусСообщения		  	  = перСтатусОжиданиеОтправки;
		МЗ.КоличествоПопыток	  	  = 0;
		МЗ.ПоследняяОшибка	 	  	  = "";
		МЗ.ВРаботе			 	  	  = Ложь;
		МЗ.ИдентификаторСообщенияВСШП = Строка(ссиСообщение.Идентификатор);	//записываем идентификатор системного сообщения
		МЗ.Записать(Истина);
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура - Актуализировать статус по отправленным сообщениям
//	Процедура вызывается из рег.задания с целью актуализации статуса по отправленным в шину сообщениям.
//	Если в системной очереди сообщения с указаным идентификатором нет, то сообщение отправлено в шину или устарело.
//	При успешном выполнении (нет сообщения в системной очереди) запись сообщения изменит статус с ОжиданиеОтправки на Отправлено.
//
Процедура АктуализироватьСтатусПоОтправленнымСообщениям() Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 50
	|	сшпОчередьИсходящихСообщений.Идентификатор
	|ИЗ
	|	РегистрСведений.сшпОчередьИсходящихСообщений КАК сшпОчередьИсходящихСообщений
	|ГДЕ
	|	сшпОчередьИсходящихСообщений.СтатусСообщения = Значение(Перечисление.сшпСтатусыСообщений.ОжиданиеОтправки)	//соберем статус по сообщениям, размещенным в системную очередь 1С:Предприятие
	|	И сшпОчередьИсходящихСообщений.КоличествоПопыток < &КоличествоПопыток
	|	И сшпОчередьИсходящихСообщений.ВРаботе = ЛОЖЬ
	|";
	
	Запрос.УстановитьПараметр("КоличествоПопыток", сшпОбщегоНазначения.ПолучитьКоличествоПопытокПередачиОбъекта());
	
	ГСЧ = Новый ГенераторСлучайныхЧисел();
	
	перСтатусОтправлено = Перечисления.сшпСтатусыСообщений.Отправлено;
	
	Пока Истина Цикл
		
		//В каждой итерации цикла из очереди (РС) формируется выборка объектов количеством не более 50 штук.
		//В выборку попадают объекты, которые:
		//	- не обрабатываются другим экз.рег.задания
		//	- количество попыток мигрировать их в СШП не более раз* (контролируется константой)
		//
		//Из сформированной выборки объектов случайным образом выбираем один объект
		//и предпринимаем попытку его миграции в СШП.
		//
		//Цикл бесконечный и прерывается только в случае отсутствие объектов в очереди
		//удовлетворяющих условиям попадания в выборку.
		
		тзВыборкаОбъектов = Запрос.Выполнить().Выгрузить();	//формируем выборку объектов.
		чРазмерВыборки = тзВыборкаОбъектов.Количество();
		Если чРазмерВыборки = 0 Тогда
			
			//Нет объектов для миграции в СШП.
			
			Прервать;
			
		КонецЕсли;
		
		НомерСС = ГСЧ.СлучайноеЧисло(0, чРазмерВыборки - 1);
		
		ИдентификаторСообщения = тзВыборкаОбъектов[НомерСС].Идентификатор;	//выбираем из выборки объектов случайным образом объект для миграции его в СШП.
		
		НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);
		
		Блокировка  		= Новый БлокировкаДанных;
		ЭлементБлокировки   = Блокировка.Добавить("РегистрСведений.сшпОчередьИсходящихСообщений");
		ЭлементБлокировки.УстановитьЗначение("Идентификатор", ИдентификаторСообщения);
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
		
		Попытка
			
			Блокировка.Заблокировать();
			
		Исключение
			
			ЗафиксироватьТранзакцию();	//например, объект блокирован другим экз.рег.задания.
			
			Продолжить;
			
		КонецПопытки;
		
		МЗ = РегистрыСведений.сшпОчередьИсходящихСообщений.СоздатьМенеджерЗаписи();
		МЗ.Идентификатор = ИдентификаторСообщения;
		МЗ.Прочитать();
		
		Если Не МЗ.Выбран() Тогда
			
			ЗафиксироватьТранзакцию();	//объект уже обработан другим экз.рег.задания.
			
			Продолжить;
			
		ИначеЕсли МЗ.ВРаботе Тогда
			
			ЗафиксироватьТранзакцию();	//объект в работе у другого экз.рег.задания.
			
			Продолжить;
			
		Иначе
			
			//Ставим метку для других экз.рег.заданий, что объект взят в работу.
			
			МЗ.ВРаботе = Истина;
			МЗ.Записать(Истина);
			
			ЗафиксироватьТранзакцию();
			
		КонецЕсли;
		
		/////
		//04.11.18
		//ВАЖНО: Если далее произойдет завершение процесса 1С, то в очереди (РС) останется объект,
		//который помечен "В работе" и в итоге:
		//	- нет процесса экз.рег.задания, которое обрабатывало объект
		//	- объект в виду статуса не будет попадать в выборки других экз.рег.заданий
		//То есть объект не будет мигрировать в СШП ("завис" в миграции).
		//
		//Проведем наблюдения на образование подобных "висяков", если будет иметь место,
		//то добавим параметр в очередь (например, ID процесса или время размещения в очереди)
		//по анализу которого будем признак "В работе" снимать.
		
		фстДанные = сшпРаботаСКлассамиСервер.ПолучитьСтруктуруДанныхДляФормированияСообщенияВСШП(МЗ.Класс);
		
		/////
		//Структура данных для формирования сообщения / получения данных по сообщению получена.
		
		Попытка
			
			///////////////////////////////////////////////////////////
			//Формируем запрос в системную очередь по УИД-у сообщения//
			///////////////////////////////////////////////////////////
			
			ссСервисИнтеграции = СервисыИнтеграции[фстДанные.ИмяСервисаИнтеграции];
			
			//Можно добавить проверку на активность сервиса. Пока оставили в общей попытке
			
			ОтборСообщений = Новый Структура;
			ОтборСообщений.Вставить("Идентификатор", Новый УникальныйИдентификатор(МЗ.ИдентификаторСообщенияВСШП));
			массивРезультат = ссСервисИнтеграции[фстДанные.ИмяКанала].ВыбратьСообщения(ОтборСообщений);
			
			Если массивРезультат.Количество() = 0 Тогда
				
				////////////////////////////////////////////////////////////////////
				//Сообщение доставлено из системной очереди в 1С:Шину или устарело//
				////////////////////////////////////////////////////////////////////
				
				//Обработка выполнена успешно, обновляем запись в очереди.
				МЗ.СтатусСообщения	 = перСтатусОтправлено;
				МЗ.КоличествоПопыток = 0;
				МЗ.ПоследняяОшибка	 = "";
				МЗ.ДатаДоставки		 = ТекущаяДатаСеанса();
				
			Иначе
				
				//////////////////////////////////////////////////////////////
				//Сообщение еще находится в системной очереди 1С:Предприятия//
				//////////////////////////////////////////////////////////////
				
			КонецЕсли;
			
			МЗ.ВРаботе = Ложь;
			МЗ.Записать(Истина);
			
		Исключение
			
			Инфо			  = ОписаниеОшибки();
			стрИмяСобытия  	  = сшпОбщегоНазначенияПовтИсп.ИмяСобытияЖурналаРегистрации();
			УровеньСобытия 	  = УровеньЖурналаРегистрации.Ошибка;
			стрОписаниеОшибки = НСтр("ru = 'При запросе статуса отправки сообщения в системную очередь 1С:Предприятия для сообщения с идентификатором: """ +  МЗ.Идентификатор + """ возникла ошибка:
			|" + Инфо + "'", сшпОбщегоНазначенияПовтИсп.КодОсновногоЯзыка());
			
			ЗаписьЖурналаРегистрации(стрИмяСобытия, УровеньСобытия,, МЗ.Идентификатор, стрОписаниеОшибки);
			
			//Фиксируем не успешную попытку формирования сообщения и его размещения в системной очереди 1С:Предприятия.
			МЗ.КоличествоПопыток = МЗ.КоличествоПопыток + 1;
			МЗ.ПоследняяОшибка 	 = Инфо;
			МЗ.ВРаботе			 = Ложь;
			МЗ.Записать(Истина);
			
			Продолжить;
			
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ВходящаяОчередь

// Процедура - Обработать входящую очередь
//	Процедура вызывается из рег.задания для выполнения задач:
//		- проверить тело сообщения и получить структуру данных примитивного типа
//		- найти класс интеграции и подготовить обработчик
//		- выполнить обработчик
//	При успешном выполнении запись сообщения изменит статус с Новое на Обработано.
//
Процедура ОбработатьВходящуюОчередь() Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 50
	|	сшпОчередьВходящихСообщений.ИдентификаторСообщенияВСШП КАК Идентификатор
	|ИЗ
	|	РегистрСведений.сшпОчередьВходящихСообщений КАК сшпОчередьВходящихСообщений
	|ГДЕ
	|	сшпОчередьВходящихСообщений.СтатусСообщения = Значение(Перечисление.сшпСтатусыСообщений.Новое)
	|	И сшпОчередьВходящихСообщений.КоличествоПопыток < &КоличествоПопыток
	|	И сшпОчередьВходящихСообщений.ВРаботе = ЛОЖЬ
	|";
	
	Запрос.УстановитьПараметр("КоличествоПопыток", сшпОбщегоНазначения.ПолучитьКоличествоПопытокПередачиОбъекта());
	
	ГСЧ = Новый ГенераторСлучайныхЧисел();
	
	перСтатусОбработано = Перечисления.сшпСтатусыСообщений.Обработано;
	
	Пока Истина Цикл
		
		//В каждой итерации цикла из очереди (РС) формируется выборка объектов количеством не более 50 штук.
		//В выборку попадают объекты, которые:
		//	- не обрабатываются другим экз.рег.задания
		//	- количество попыток мигрировать их в СШП не более раз* (контролируется константой)
		//
		//Из сформированной выборки объектов случайным образом выбираем один объект
		//и предпринимаем попытку его миграции в СШП.
		//
		//Цикл бесконечный и прерывается только в случае отсутствие объектов в очереди
		//удовлетворяющих условиям попадания в выборку.
		
		тзВыборкаОбъектов = Запрос.Выполнить().Выгрузить();	//формируем выборку объектов.
		чРазмерВыборки = тзВыборкаОбъектов.Количество();
		Если чРазмерВыборки = 0 Тогда
			
			//Нет объектов для миграции в СШП.
			
			Прервать;
			
		КонецЕсли;
		
		НомерСС = ГСЧ.СлучайноеЧисло(0, чРазмерВыборки - 1);
		
		ИдентификаторСообщения = тзВыборкаОбъектов[НомерСС].Идентификатор;	//выбираем из выборки объектов случайным образом объект для миграции его в СШП.
		
		НачатьТранзакцию(РежимУправленияБлокировкойДанных.Управляемый);
		
		Блокировка  		= Новый БлокировкаДанных;
		ЭлементБлокировки   = Блокировка.Добавить("РегистрСведений.сшпОчередьВходящихСообщений");
		ЭлементБлокировки.УстановитьЗначение("ИдентификаторСообщенияВСШП", ИдентификаторСообщения);
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
		
		Попытка
			
			Блокировка.Заблокировать();
			
		Исключение
			
			ЗафиксироватьТранзакцию();	//например, объект блокирован другим экз.рег.задания.
			
			Продолжить;
			
		КонецПопытки;
		
		МЗ = РегистрыСведений.сшпОчередьВходящихСообщений.СоздатьМенеджерЗаписи();
		МЗ.ИдентификаторСообщенияВСШП = ИдентификаторСообщения;
		МЗ.Прочитать();
		
		Если Не МЗ.Выбран() Тогда
			
			ЗафиксироватьТранзакцию();	//объект уже обработан другим экз.рег.задания.
			
			Продолжить;
			
		ИначеЕсли МЗ.ВРаботе Тогда
			
			ЗафиксироватьТранзакцию();	//объект в работе у другого экз.рег.задания.
			
			Продолжить;
			
		Иначе
			
			//Ставим метку для других экз.рег.заданий, что объект взят в работу.
			
			МЗ.ВРаботе = Истина;
			МЗ.ДатаОбработки = ТекущаяДатаСеанса();
			МЗ.Записать(Истина);
			
			ЗафиксироватьТранзакцию();
			
		КонецЕсли;
		
		/////
		//04.11.18
		//ВАЖНО: Если далее произойдет завершение процесса 1С, то в очереди (РС) останется объект,
		//который помечен "В работе" и в итоге:
		//	- нет процесса экз.рег.задания, которое обрабатывало объект
		//	- объект в виду статуса не будет попадать в выборки других экз.рег.заданий
		//То есть объект не будет мигрировать в СШП ("завис" в миграции).
		//
		//Проведем наблюдения на образование подобных "висяков", если будет иметь место,
		//то добавим параметр в очередь (например, ID процесса или время размещения в очереди)
		//по анализу которого будем признак "В работе" снимать.
		
		Попытка
			
			мвКлассыИнтеграции = сшпРаботаСКлассамиСервер.ПолучитьМассивКлассовПоИмени(МЗ.КлассВСШП);
			Если мвКлассыИнтеграции.Количество() = 0 Тогда
				
				//Не найден класс интеграции по имени.
				
				стрИмяСобытия	  = сшпОбщегоНазначенияПовтИсп.ИмяСобытияЖурналаРегистрации();
				УровеньСобытия	  = УровеньЖурналаРегистрации.Ошибка;
				стрОписаниеОшибки = НСтр("ru = 'Не найден класс интеграции с именем : """ + МЗ.КлассВСШП + """.'", сшпОбщегоНазначенияПовтИсп.КодОсновногоЯзыка());
				
				ЗаписьЖурналаРегистрации(стрИмяСобытия, УровеньСобытия,, МЗ.КлассВСШП, стрОписаниеОшибки);
				
				МЗ.КоличествоПопыток = МЗ.КоличествоПопыток + 1;
				МЗ.ПоследняяОшибка	 = стрОписаниеОшибки;
				МЗ.ВРаботе			 = Ложь;
				МЗ.ДатаОбработки	 = Дата(1, 1, 1);
				МЗ.Записать(Истина);
				
				Продолжить;
				
			ИначеЕсли мвКлассыИнтеграции.Количество() > 1 Тогда
				
				//Найдено несколько классов интеграции по имени.
				
				стрИмяСобытия	  = сшпОбщегоНазначенияПовтИсп.ИмяСобытияЖурналаРегистрации();
				УровеньСобытия	  = УровеньЖурналаРегистрации.Ошибка;
				стрОписаниеОшибки = НСтр("ru = 'Найдено несколько классов интеграции с именем : """ + МЗ.КлассВСШП + """.'", сшпОбщегоНазначенияПовтИсп.КодОсновногоЯзыка());
				
				ЗаписьЖурналаРегистрации(стрИмяСобытия, УровеньСобытия,, МЗ.КлассВСШП, стрОписаниеОшибки);
				
				МЗ.КоличествоПопыток = МЗ.КоличествоПопыток + 1;
				МЗ.ПоследняяОшибка	 = стрОписаниеОшибки;
				МЗ.ВРаботе			 = Ложь;
				МЗ.ДатаОбработки	 = Дата(1, 1, 1);
				МЗ.Записать(Истина);
				
				Продолжить;
				
			КонецЕсли;
			
			/////
			//Класс интеграции для обработки сообщения получен.
			ссКлассИнтеграции = мвКлассыИнтеграции[0];
			
			/////
			//Структура данных примитивного типа, которые были переданы, получена.
			стДанные = сшпФункцииРаботыJSON.ПростоеЧтениеJSON(МЗ.Тело);
			
			Попытка
				
				//////////////////////////////////////////
				//Выполняем обработчик класса интеграции//
				//////////////////////////////////////////
				стПараметрыВызова = Новый Структура;
				стПараметрыВызова.Вставить("ПроцедураОбработки", ссКлассИнтеграции.ПроцедураОбработки);
				//стПараметрыВызова.Вставить("Параметры", Неопределено);	//зарезервировано
				
				фстПараметрыВызова = Новый ФиксированнаяСтруктура(стПараметрыВызова);
				
				ВыполнитьОбработчикКлассаВходящий(стДанные, фстПараметрыВызова);
				
			Исключение
				
				Инфо			  = ОписаниеОшибки();
				стрИмяСобытия  	  = сшпОбщегоНазначенияПовтИсп.ИмяСобытияЖурналаРегистрации();
				УровеньСобытия 	  = УровеньЖурналаРегистрации.Ошибка;
				стрОписаниеОшибки = НСтр("ru = 'При выполнении обработчика класса интеграции: """ + ссКлассИнтеграции + """  возникла ошибка:
				|" + Инфо + "'", сшпОбщегоНазначенияПовтИсп.КодОсновногоЯзыка());
				
				ЗаписьЖурналаРегистрации(стрИмяСобытия, УровеньСобытия, ссКлассИнтеграции.Метаданные(), ссКлассИнтеграции, стрОписаниеОшибки);
				
				//Фиксируем не успешную попытку выполнения обработчика класса интеграции для объекта.
				МЗ.КоличествоПопыток = МЗ.КоличествоПопыток + 1;
				МЗ.ПоследняяОшибка 	 = Инфо;
				МЗ.ВРаботе			 = Ложь;
				МЗ.ДатаОбработки	 = Дата(1, 1, 1);
				МЗ.Записать(Истина);
				
				Продолжить;
				
			КонецПопытки;
			
			//Обработка выполнена успешно, обновляем запись в очереди.
			МЗ.СтатусСообщения	 = перСтатусОбработано;
			МЗ.КоличествоПопыток = 0;
			МЗ.ПоследняяОшибка	 = "";
			МЗ.ВРаботе			 = Ложь;
			МЗ.Класс			 = ссКлассИнтеграции;
			МЗ.Записать(Истина);
			
		Исключение
			
			//Общее исключение при миграции объекта в СШП (используется при общем разборе ошибок).
			//Например, при получении определения структуры класса интеграции.
			МЗ.КоличествоПопыток = МЗ.КоличествоПопыток + 1;
			МЗ.ПоследняяОшибка	 = ОписаниеОшибки();
			МЗ.ВРаботе			 = Ложь;
			МЗ.ДатаОбработки	 = Дата(1, 1, 1);
			МЗ.Записать(Истина);
			
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область ПрограммныйИнтерфейсДляОбработчиковКлассовИнтеграции

// Функция - Зарегистрировать событие для объекта
//
// Параметры:
//  ссИсточник - Справочник.Ссылка, Документ.Ссылка, РегистрСведений.НаборЗаписей (зарезервировано) - ссылка на объект-источник события.
//	ЭтоРегистр - булево - это событие регистрации регистра (зарезервировано)
//	ЭтоУдаление - булево - это удаление (зарезервировано)
// Возврат:
//	Истина 	- сообщения для объекта размещены в очереди
//	Ложь	- при размещении сообщений для объекта в очереди возникли ошибки. Подробности см. ЖР
//
Функция ЗарегистрироватьСобытиеДляОбъекта(ссИсточник, ЭтоРегистр = Ложь, ЭтоУдаление = Ложь) Экспорт
	
	Возврат ЗарегистрироватьСобытие(ссИсточник, ЭтоРегистр, ЭтоУдаление);	//алгоритм аналогичен работе подписки на событие
	
КонецФункции

// Функция - Зарегистрировать событие для класса интеграции
//
// Параметры:
//  ссКлассИнтеграции 	- Справочник.сшпКлассыИнтеграции - ссылка на класс интеграции.
//	стВходящиеПараметры - структура / Неопределено - входящие параметры, которые нужно учесть при формировании тела сообщения
//							если параметры передавать не нужно, то используется Неопределено
// Возврат:
//	Истина 	- сообщения для класса интеграции размещены в очереди
//	Ложь	- при размещении сообщений для класса интеграции в очереди возникли ошибки. Подробности см. ЖР
//
Функция ЗарегистрироватьСобытиеДляКлассаИнтеграции(ссКлассИнтеграции, стВходящиеПараметры = Неопределено) Экспорт
	
	Возврат ПоместитьВОчередьИсходящих(Неопределено, ссКлассИнтеграции, стВходящиеПараметры);
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПроцедурыИФункцииДляОбработкиИсходящейОчереди

// Функция - Зарегистрировать событие
//
// Параметры:
//  ссИсточник - Справочник.Ссылка, Документ.Ссылка, РегистрСведений.НаборЗаписей (зарезервировано) - ссылка на объект-источник события.
//	ЭтоРегистр - булево - это событие регистрации регистра (зарезервировано)
//	ЭтоУдаление - булево - это удаление (зарезервировано)
// Возврат:
//	Истина 	- сообщения для объекта размещены в очереди
//	Ложь	- при размещении сообщений для объекта в очереди возникли ошибки. Подробности см. ЖР
//
Функция ЗарегистрироватьСобытие(ссИсточник, ЭтоРегистр = Ложь, ЭтоУдаление = Ложь)
	
	мвКлассыИнтеграции = сшпРаботаСКлассамиСервер.ПолучитьМассивКлассовДляОбъекта(ссИсточник);
	Если мвКлассыИнтеграции.Количество() = 0 Тогда
		
		//Нет классов интеграции, то есть не будем отправлять информацию по объекту в инфосистемы
		
		стрИмяСобытия	  = сшпОбщегоНазначенияПовтИсп.ИмяСобытияЖурналаРегистрации();
		УровеньСобытия	  = УровеньЖурналаРегистрации.Предупреждение;
		стрОписаниеОшибки = НСтр("ru = 'Для объекта - """ + ссИсточник + """ нет класса интеграции и он указан в подписке на СШП.
		|Нужно либо добавить класс интеграции для данного объекта, либо убрать объект из подписки на обработку в СШП'", сшпОбщегоНазначенияПовтИсп.КодОсновногоЯзыка());
		
		ЗаписьЖурналаРегистрации(стрИмяСобытия, УровеньСобытия,, ссИсточник, стрОписаниеОшибки);
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Для Каждого ТекКласс Из мвКлассыИнтеграции Цикл
		
		Если Не ПоместитьВОчередьИсходящих(ссИсточник, ТекКласс) Тогда	//для каждого класса создаем объект интеграции (сообщение)
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Функция - Поместить в очередь исходящих
//
// Параметры:
//  ссИсточник 			- Справочник.Ссылка, Документ.Ссылка, РегистрСведений.НаборЗаписей (зарезервировано) - ссылка на объект-источник события.
//							Может быть равно Неопределено, в случае формирования сообщения без объекта по классу интеграции.
//	ссКласс				- Справочник.сшпКлассыИнтеграции - ссылка на класс интеграции.
//	стВходящиеПараметры - структура - произвольная структура передаваемых параметров, по умолчанию Неопределено.
// Возврат:
//	Истина 	- сообщение размещено в очереди
//	Ложь	- сообщение не размещено в очереди, описание ошибки см. ЖР
Функция ПоместитьВОчередьИсходящих(ссИсточник, ссКласс, стВходящиеПараметры = Неопределено)
	
	Менеджер = РегистрыСведений.сшпОчередьИсходящихСообщений.СоздатьМенеджерЗаписи();
	
	//Измерения.
	Менеджер.Идентификатор = Строка(Новый УникальныйИдентификатор());
	
	//Ресурсы.
	Менеджер.Тело			   = "";
	Менеджер.СтатусСообщения   = Перечисления.сшпСтатусыСообщений.Новое;
	Менеджер.КоличествоПопыток = 0;
	Менеджер.ПоследняяОшибка   = "";
	Менеджер.ВРаботе 		   = Ложь;
	
	//Ресурсы.
	Менеджер.Объект		   = ссИсточник;	//может быть равно Неопределено
	Менеджер.Класс		   = ссКласс;
	
	Если стВходящиеПараметры <> Неопределено Тогда
		
		Если ТипЗнч(стВходящиеПараметры) = Тип("Структура") Тогда
			
			Менеджер.ВходящиеПараметры = сшпФункцииРаботыJSON.ЗаписьПрикладныхОбъектовJSON(стВходящиеПараметры);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Менеджер.ЭтоУдаление   = Ложь;	//зарезервировано
	Менеджер.ДатаСоздания  = ТекущаяДатаСеанса();
	Менеджер.ДатаОбработки = Дата(1, 1, 1);
	Менеджер.ДатаОтправки  = Дата(1, 1, 1);
	Менеджер.ДатаДоставки  = Дата(1, 1, 1);
	
	Попытка
		
		Менеджер.Записать(Истина);
		
		Возврат Истина;
		
	Исключение
		
		стрИмяСобытия	  = сшпОбщегоНазначенияПовтИсп.ИмяСобытияЖурналаРегистрации();
		УровеньСобытия	  = УровеньЖурналаРегистрации.Ошибка;
		Если ссИсточник = Неопределено Тогда
			
			стрОписаниеОшибки = НСтр("ru = 'Не удалось записать - """ + ссИсточник + """ в очередь исходящих сообщений СШП по причине: " + ОписаниеОшибки() + "'", сшпОбщегоНазначенияПовтИсп.КодОсновногоЯзыка());
			
		Иначе
			
			стрОписаниеОшибки = НСтр("ru = 'Не удалось записать в очередь исходящих сообщений СШП по причине: " + ОписаниеОшибки() + "'", сшпОбщегоНазначенияПовтИсп.КодОсновногоЯзыка());
			
		КонецЕсли;
		
		ЗаписьЖурналаРегистрации(стрИмяСобытия, УровеньСобытия,, ссИсточник, стрОписаниеОшибки);
		
		Возврат Ложь;
		
	КонецПопытки;
	
КонецФункции

// Процедура - Выполнить обработчик класса
//
// Параметры:
// 	ссИсточник 		   - Справочник.Ссылка, Документ.Ссылка, РегистрСведений.НаборЗаписей (зарезервировано) - ссылка на объект-источник события.
//	стДанные		   - Структура - определение структуры класса интеграции.
//	фстПараметрыВызова - Фиксированная структура - параметры вызова обработчика: код обработчика класса интеграции и пр.
//
Процедура ВыполнитьОбработчикКласса(ссИсточник, стДанные, фстПараметрыВызова)
	
	//Вызываем в данной области видимости выполнение обработчика класса интеграции.
	//Сделали специально, чтобы была ограниченная области видимости и доступны зарезервированные переменные;
	//	- ссИсточник - что является инициатором создания сообющения
	//	- стДанные - как мигрируем
	//	- фстПараметрыВызова - параметры вызова, только на чтение
	
	//Проверка на отсутствие кода в обработчике.
	Если ПустаяСтрока(фстПараметрыВызова.ПроцедураОбработки) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	//Подготавливаем к использованию переданные параметры, то есть введем короткое имя для удобства обращения.
	//Можно в дальнейшем сделать передачу имен переменных.
	Если фстПараметрыВызова.Свойство("Параметры") Тогда
		
		стВходящиеПараметры = фстПараметрыВызова.Параметры;
		
	Иначе
		
		стВходящиеПараметры = Новый Структура;
		
	КонецЕсли;
	
	стрКодВыполнения = сшпКомпиляция.ВыполнитьПрекомпиляцию(фстПараметрыВызова.ПроцедураОбработки);	//прекомпиляция кода обработчика
	
	Выполнить(стрКодВыполнения);
	
КонецПроцедуры

// Процедура - Добавить версию объекта
//
// Параметры:
// 	ссИсточник	- Справочник.Ссылка, Документ.Ссылка, РегистрСведений.НаборЗаписей (зарезервировано) - ссылка на объект-источник события.
//	стДанные	- Структура - определение структуры класса интеграции.
//
Процедура ДобавитьВерсиюОбъекта(ссИсточник, стДанные)
	
	ВерсияСтрокой = ссИсточник.ВерсияДанных;
	СтрокаHEX = "0x" + СтрЗаменить(Base64Значение(ВерсияСтрокой), " ", "");
	Число64 = ЧислоИзШестнадцатеричнойСтроки(СтрокаHEX);
	
	стДанные.Вставить("ВерсияДанных", Число64);
	
КонецПроцедуры

#КонецОбласти

#Область ПроцедурыИФункцииДляОбработкиВходящейОчереди

// Процедура - Выполнить обработчик класса (входящий)
//
// Параметры:
//	стДанные		   - Структура - структура данных примитивного типа.
//	фстПараметрыВызова - Фиксированная структура - параметры вызова обработчика: код обработчика класса интеграции и пр.
//
Процедура ВыполнитьОбработчикКлассаВходящий(стДанные, фстПараметрыВызова)
	
	//Вызываем в данной области видимости выполнение обработчика класса интеграции.
	//Сделали специально, чтобы была ограниченная области видимости и доступны зарезервированные переменные;
	//	- стДанные - структура переданных данных примитивного типа
	//	- фстПараметрыВызова - параметры вызова, только на чтение
	
	//Проверка на отсутствие кода в обработчике.
	Если ПустаяСтрока(фстПараметрыВызова.ПроцедураОбработки) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	//Подготавливаем к использованию переданные параметры, то есть введем короткое имя для удобства обращения.
	//Можно в дальнейшем сделать передачу имен переменных.
	Если фстПараметрыВызова.Свойство("Параметры") Тогда
		
		стВходящиеПараметры = фстПараметрыВызова.Параметры;
		
	Иначе
		
		стВходящиеПараметры = Новый Структура;
		
	КонецЕсли;
	
	стрКодВыполнения = сшпКомпиляция.ВыполнитьПрекомпиляцию(фстПараметрыВызова.ПроцедураОбработки);	//прекомпиляция кода обработчика
	
	Выполнить(стрКодВыполнения);
	
КонецПроцедуры

#КонецОбласти

#Область API_ПредопределенныеМетодыДоступныеВОбработчикахКлассаИнтеграции_01

// Функция - Получить дату
//	Преобразовывает значение типа Дата из строки в формате JSON (форммат ISO)
//	Предназначена для использования в обработчках классов интеграции
//
// Параметры:
//  jsonДата - строка - значение даты в строке в формате JSON
// Возврат:
//	дтЗначение - дата - значение типа Дата
//
Функция ПолучитьДату(jsonДата)
	
	дтЗначение = ПрочитатьДатуJSON(jsonДата, ФорматДатыJSON.ISO);
	
	Возврат дтЗначение;
	
КонецФункции

// Функция - Ссылка существует
// 	Проверяет физическое наличие записи в информационной базе данных о переданном значении ссылки.
//
// Параметры:
//  ПроверяемаяСсылка - ЛюбаяСсылка - значение любой ссылки информационной базы данных.
// 
// Возвращаемое значение:
//  Булево - Истина, если существует.
//
Функция СсылкаСуществует(ПроверяемаяСсылка)
	
	//Применение:
	//В вызывающей функции: ссНоменклатура = Справочники.Товары.ПолучитьСсылку(уидТовара);	//по УИД-у, если на входе строка, 
																							//то использовать: Новый УникальныйИдентификатор(стрУИДТовара);
	// боСуществует = СсылкаСуществует(ссНоменклатура);
	
	ТекстЗапроса = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	1 КАК Поле1
		|ИЗ
		|	&ИмяТаблицы КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяТаблицы", ИмяТаблицыПоСсылке(ПроверяемаяСсылка));
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", ПроверяемаяСсылка);
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат НЕ Запрос.Выполнить().Пустой();
	
КонецФункции

// Функция - Имя таблицы по ссылке
// 	Возвращает полное имя объекта метаданных по переданному значению ссылки.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, для которого необходимо получить имя таблицы ИБ.
// 
// Возвращаемое значение:
//  Строка - полное имя объекта метаданных для указанного объекта. Например: "Справочник.Номенклатура".
//
Функция ИмяТаблицыПоСсылке(Ссылка)
	
	Возврат Ссылка.Метаданные().ПолноеИмя();
	
КонецФункции

#КонецОбласти

#КонецОбласти